Move TODO points out to GitHub issues...

Arc2d.from :: Point2d -> Point2d -> Angle -> Arc2d
Arc2d.leftTurn :: Point2d -> Point2d -> Arc2d
Arc2d.rightTurn :: Point2d -> Point2d -> Arc2d

Have separate rotateClockwiseAround and rotateCounterclockwiseAround functions everywhere?
-> rotateCwAround, rotateCcwAround? ugh
-> rotateClockwiseAround, rotateAnticlockwiseAround?

Get Python docs publishing working
-> maybe just generate Sphinx-flavoured reStructuredText instead of tyring to use autodoc?
  -> full control over docs structure
  -> don't have to mess around with settings to get autodoc to be able to import 'opensolid' module
  -> one less dependency
  -> won't capture manual additions to the generated Python file though...
-> maybe try running autodoc using built wheel instead of in source directory?

Have SpurGear be a pure interface?
-> possibly add typeclass instance for '(Named "numTeeth" Int, Named "module" Length)' (anonymous record!)

Switch to providing an Axis3d instead of Axis2d for revolved bodies?
-> might be just fine to allow axes that do not in fact lie within the sketch plane
-> providing an absolute axis seems generally more readable than a relative one...
-> a bit tricky, since we need to check for profile curves that lie *on* the axis...
  -> convert everything to 3D and *then* check for curves lying on the axis?

Optimized representation for planar surface functions
- Update Ast module to use p0/i/j representation instead of planes?
- Rename Ast.PlacePoint2d to Ast.PlanarPoint2d, Ast.PlaceVector2d to PlanarVector2d

Add Arc#d bytecode instructions

Optimize Ast operations for Bezier curves
-> xComponent, yComponent, rightwardComponent, forwardComponent, upwardComponent
-> dot product and cross product
-> sum, difference, product and quotient with constant

Base arc length parameterization on *square* of first derivative magnitude, then cache it by storing it lazily?
-> will require a bit of tweaking derivative logic, but hopefully doable...

Implement generic Mesh class manually in each target language?
-> probably expose something like a MeshImpl class that just works with positions and vertex indices
-> expect target language to store actual vertices in its own array

Profile with ThreadScope to check for parallelization issues?

Implement arc length parameterization in C++

Update UV version in GitHub Actions

Have Units.Coercion implementations just call a type-specific 'coerce' function everywhere?
-> some places may not need Units.Coercion at all, should only be needed for arithmetic?

Add 'components'/'coordinates' functions to curve and surface function types
-> especially useful for constructing derivatives of function compositions

Rename CompiledFunction to Function.Compiled
-> or possibly Evaluator or similar?
  -> then might make sense to *not* implement Addition etc. for Evaluator, just use map2 (+) (+) (+) etc.

Support discontinuities in bytecode

Update Curve.sqrt' and SurfaceFunction.sqrt' to use specialized square root derivative expression

Do a general pass of trimming down .hs-boot files?
-> remove constructors, in particular curve/surface functions

Specialized docstrings for UvCurve and UvRegion

Switch to 'perfect' units coercion for curves and surface function types
-> can coerce Haskell functions!

Check that function modules only refer to other function types, not geometry types

Special cases for arithmetic on mixed variable/constant Ast values
- e.g. 'a + (b + x)' -> (a + b) + x'

Review all 'sqrt', 'magnitude', 'direction' and 'tangentDirection' functions to ensure correct degeneracy removal
-> get rid of 'unsafeMagnitude' functions and 'NonZeroMagnitude' types

Ensure all quotient implementations use (p' / q) - (p / q) * (q' / q) form, to better support L'Hopital

Remove hasZero functions?
-> also isZero? Just use ^ and ~= instead...

Improve curve linearization to take first-order bounds and even just zeroth-order bounds into account
-> behave better when second derivative is poorly conditioned

Useful operations:
- Booleans on regions
- extract/query region/body curves, points, surfaces?

Add DirectionCurve2d.[rotateLeftward,rotateRightward] and use in Curve2d.offsetBy, Region2d.fillet

Add OpenSolid prefix to API modules

Add Linear transformation types?
-> can only be used for vector types
-> rename Affine to Positioned or Positional similar?

Reconsider having Axis2d.u, Point2d.uv etc. specialized constants/constructors?
-> maybe even move UvSpace into main CoordinateSystem module...and remove UvPoint etc. type aliases?
-> simpler to just use Point2d constructor directly, instead of Point2d.uv

Steiner point optimization: discard UV subdomains that touch an outer boundary of the overall domain bounding box but *don't* touch a boundary curve/edge
-> useful for thin regions, e.g. those resulting from domain stretching...

General pass to make sure transformation functions are complete and consistent

Refactor Solve2d searching to use 'cross product' of Solve1d?

Verify behaviour of Curve2d intersection when curves are extensions of each other and meet only at an endpoint
-> rework overlap detection to be based on G2 continuity?

Have Domain.samplingPoints etc. return a 'Result InfiniteRecursion (NonEmpty Float)'?

Refactor Surface3d.toMesh to match Body3d

Meshing improvements:
- Scale UV domain based on relative fuu and fvv magnitudes, so that e.g. cylinder gets triangulated as strip
- Or perhaps better: scale UV domain domain based on relative fu and fv magnitudes, to get better triangle aspect ratios?
- Properly handle UV domains with extreme aspect ratios: take overall bounds and have initial step that splits into square-ish segments?

Support Point3d + VectorSurfaceFunction3d -> SurfaceFunction3d

Add transformBy to all curve, surface and surface function types
-> then search for transformByImpl instances to see if they can be updated to use transformBy instead of Transformed constructors

Optimize Set2d to use 'nth element' algorithm?
- recursively search for bisection value to balance two sub-lists?

Rewrite scripts in Haskell?
-> or Python?
  -> Haskell better, might have multiple target languages but Haskell will still be primary for a long time...
-> first up: regenerating hie.yaml to use 'flib' for opensolid-ffi
  -> perhaps also combined script to add a new test executable and update hie.yaml

C API: generate structs with *named* fields
-> have the struct be named as function_name_inputs, function_name_outputs etc.
-> can use this in Python too, to have named fields instead of 'field0' etc.

Improve Python bindings
- Add magic IPython display functions to Curve2d, Drawing2d.Entity etc.
  -> using to-SVG (and eventually to-glTF) Haskell functions under the hood? ('display' functions?)
- Actual error types instead of strings
- Add _list_decode helper?
- Add support for 'intersects' operator (^)
  -> Also (&) for *intersection*?
- Add extra line to docstring mentioning tolerance, if one is required
- Add support for composition (special support for languages that support callable objects?)

Try using Pandoc to convert from Haddock to reStructuredText?
-> or just write all doc comments in plain text...
-> or use specialized direct Haddock conversion - most flexible
   -> e.g. convert type/function names to correct target language casing

Add support for Drawing2d.auto or similar, that computes an appropriate bounding box?
-> or perhaps a few different options for specifying canvas: Drawing2d.bounds, Drawing2d.padding etc.
-> maybe add 'bounds' field to Drawing2d type, and support operations like 'expand bounds by given amount'?

Try generating C# bindings?

Add extension method to tuple types in target languages that support them:
  -> (start, end).steps(10) <-- nicely symmetric with Parameter.steps(10)
  -> (start, end).interpolate(0.3)

Try generating C++ bindings?

Sandbox executable to start generating Region2d medial axis curves and points?
-> need to be able to solve for medial axis of curve and *point* first

Refactor Estimate to return an error if convergence fails/stalls
