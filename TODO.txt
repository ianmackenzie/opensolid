Implement composition of SurfaceFunction2d and DirectionSurfaceFunction#d

Review uses of Tolerance.[squared,squared'] to see if there are alternatives...
-> e.g. for square root desingularization, check if second derivative is at least 1e9 times bigger than zeroth or first derivatives?
-> maybe go back to idea of explicit normalization functions, where it's known a priori that e.g. first derivative of squared magnitude is zero where magnitude is zero...
-> also generally review uses of ~= to see where first derivative is being checked
-> add Tolerance.firstDerivative function that takes second derivative value as input?

Change desingularize functions to take 'function' as regular, unnamed argument?
-> also change Curve desingularization functions to take 'normal' function as first argument, for consistency?

Ensure all curves and surface functions implement placeIn, relativeTo, transformBy, projectInto, on as appropriate

Ensure all curves implement composition with Curve Unitless

Ensure all surface functions implement composition or SurfaceFunction2d UvCoordinates

Add simplified/optimized versions of blending function derivatives

Add dedicated bytecode instructions for blending functions (and their derivatives)
-> they'll get evaluated every time a desingularized function is evaluated, regardless of whether or not the result is used...
-> or maybe add conditional evaluation to bytecode?

Update Curve.quotient to also compute derivative for use in constructing blending curve

Replace 'synthetic' curves with plain quartic Hermite splines

Merge e.g. 'Subdomain' and 'Domain1d'?
- just base on Float values instead of Int
- store recursion type (even though that could be inferred from endpoints...)

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Try using RequiredTypeArguments extension to avoid need for Proxy in FFI-related code?
-> a bit tricky since the 'representation' function probably still needs to take a Proxy argument...

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Rename ZeroEverywhere -> IsZero?
-> shorter and more consistent with e.g. IsPoint
-> keep DivisionByZero to indicate specifically that denominator is zero

Review uses of unsafeQuotient

Refactor Qty.steps etc. to take count argument first?
-> 'count' refers to the first argument, like 'translateBy' refers to its first argument...

Re-introduce Functions or similar module so that all typeclass instances can be defined there?

Review all 'sqrt', 'magnitude', 'direction' and 'tangentDirection' functions to ensure correct degeneracy removal
-> get rid of 'unsafeMagnitude' functions and 'NonZeroMagnitude' types

Use FFI struct syntax for calling into C++ as well as for target languages calling into Haskell?
-> avoid custom pokeElemOff etc. stuff when calling into C++
-> a bit less efficient in some cases though since e.g. allocating space for a list of values uses callocBytes (maybe should be mallocBytes?) instead of allocaBytes
  -> maybe have a way to indicate to FFI.store whether to use mallocBytes or allocaBytes?

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Update API.Class.buildClass to use field accessor syntax

Refactor Solve2d searching to use 'cross product' of Solve1d?

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)

Support optional named arguments in target languages
- maybe via wrapper functions where one argument is something like an 'Options a' value,
  wrapping a list of options/attributes in Haskell

Switch Body3d.cylinderAlong to accept separate start and end values instead of a Bounds
-> maybe Body3d.extruded, too? easier now that named arguments are supported...

Refactor tolerance handling in Python?
- set tolerances for different units separately/independently
- convenience functions like 'Tolerance.meters(1e-9)', 'Tolerance.degrees(1e-3)', 'Tolerance.unitless(1e-12)' etc.?
- also generic ones like 'Tolerance.length(Length.micrometers(10))' etc.
- have default tolerances pre-configured? 1e-9 meters, radians, and unitless...
  -> middle ground: 'Tolerance.defaults()' to set up default tolerances for everything
