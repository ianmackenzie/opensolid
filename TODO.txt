Improve Python bindings
- Extend API.functions to return function signatures as well?
  -> add API.Function type (or repurpose the API.ForeignFunction name...)
  -> might then be able to remove Python-specific type traversal code that generates FFI classes
- Use simple isinstance checks for binary operator overloads
  -> there will always be a single positional argument, never a named one...
- Try switching to pattern matching just on 'shape' of function arguments, with separate 'isinstance' checks
- Nice __repr__ and/or __str__ for primitive types
- Add arithmetic operators (including for Qty values)
- Add consructors/conversions to Qty modules based on conversion factors provided as part of API definition?
- Support lists
- Support 'in' operator?
- Add docstrings
- Define class (and quantity) members "in place" in FFI typeclass instance instead of separately?
- Actual error types instead of strings
- Clean up nested class definition somehow?
- Add runtime checks that classes defined in OpenSolid.API module have matching names in their types' FFI instances
- Add _list_decode helper?
- Get lists arguments working
  - allocate memory with opensolid_malloc
  - cast result to typed pointer with 'ctypes.cast(obj, type)'?
  - get/set elements with 'ptr[index]'

Switch Solve2d.return back to taking a single value instead of a NonEmpty

Move Http module out into separate opensolid-http package
-> reduce dependencies of libopensolid-ffi.so

Try publishing to PyPI
-> can start with test.pypi.org (using fake package name)
-> some combination of uv and cibuildwheel?

Operator overload test suite: for every valid type and units combination, test that e.g. zero vector * zero range = zero vector bounds
- ensure every valid overload actually exists, and is resolved correctly at runtime

Try generating C# bindings?

Try generating C++ bindings?

Sandbox executable to start generating Region2d medial axis curves and points?
-> need to be able to solve for medial axis of curve and *point* first

Introduce curve function types and properly support piecewise curves

Switch types back to 'space @ units' instead of 'coordinateSystem' where possible?
-> if that makes coercion more expensive, specialize arithmetic operators instead

Implement 1D monotonic solving in Rust

Specialize xComponent etc. for Parametric cases

Move primitives to Primitives.hs

Use space1 ~ space2 instead of space ~ space_ everywhere

Refactor Estimate to return an error if convergence fails/stalls

Specialize Multiplication for primitive types, for performance
-> avoid units coercion and extra typeclass lookup

Optimizations to try:
- cache expressions on Rust side (per thread?)
- refactor JIT code to directly generate 'primop' style code directly callable from Haskell
- add CMM wrappers around C functions so they can be directly used as primops
