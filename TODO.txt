Rename Bounds to Interval?
- allows use of Bounds as typeclass / name of generic module
- make sure comment in Body3D.hs stays as "Bounds on 3D curve" instead of "Interval on 3D curve"...

Add missing operators
- Failed to add UvPoint and Vector2D
- Failed to add UvBounds and Vector2D
- Failed to subtract UvPoint and Vector2D
- Failed to subtract UvBounds and Vector2D
- Failed to divide float and Curve
- Failed to divide Length and Curve
- Failed to divide Length and LengthCurve
- Failed to divide Area and Curve
- Failed to divide Area and LengthCurve
- Failed to divide Area and AreaCurve
- Failed to divide Angle and Curve
- Failed to divide Angle and AngleCurve
- Failed to divide Curve and Curve
- Failed to divide LengthCurve and Curve
- Failed to divide LengthCurve and LengthCurve
- Failed to divide AreaCurve and Curve
- Failed to divide AreaCurve and LengthCurve
- Failed to divide AreaCurve and AreaCurve
- Failed to divide AngleCurve and Curve
- Failed to divide AngleCurve and AngleCurve

Ensure check_operators.py includes all relevant classes

Remove UvPoint and UvBounds modules?
- replace UvBounds.unitSquare with Bounds2D.uvDomain
  - also rename Region2D.unitSquare to Region2D.uvDomain?
- replace UvPoint.samples with Bounds2D.samples
- replace UvPoint.random with Point2D.random

Remove Quantity 'small' and 'large' functions in favour of using minimum/maximum functions with Quantity.abs
-> e.g. 'Quantity.smallestBy foo' is 'NonEmpty.minimumBy (Quantity.abs . foo)'

Rule for properties/fields in target languages: O(1) and guaranteed to succeed?

Try removing Expression.* modules?
- see if they're actually still necessary/useful for type inference...

Allow Set#D to be empty?
- would have to remove Set#D.bounds but that's probably OK...

Refactor Polygon2d.edges to filter out (approximately) zero-length edges?
- useful for removing duplicate last edge if last vertex is equal to first vertex
- often have polygons in UV space though...maybe just use *exact* equality?

Refactor curve construction from line segments?
- maybe also rename Curve2d.arc to Curve2d.arcFrom, add Arc2D type?
  - then move:
    - Curve2d.polarArc to Arc2d.polar
    - Curve2d.sweptArc to Arc2d.swept
    - Curve2d.cornerArc to Arc2d.corner
      - or Curve2d.fillet, since it can produce a line
      - or just remove it, since we have Region2d.fillet which is more flexible/powerful
      - or change Curve2d.fillet to act on two arbitrary curves?
    - Curve2d.radiusArc to Arc2d.withRadius or Arc2d.svg
      - replace WhichArc type with named #small argument plus Sign argument?
        - WhichArc seems nice, perhaps renamed to Arc2d.Which...
    - keep Curve2d.arcFrom without equivalent in Arc2d,
      since that can actually result in a line instead
- could then add Curve2d.asLine, Curve2d.asArc, Curve2d.asCircle etc.
- could also have Curve2D.Line, Curve2D.Arc, Curve2D.LineFrom, Curve2D.ArcFrom patterns
  - should even be able to map those to Python patterns!
- do for Curve3D too...add Line3D etc.

Add Bezier#D etc. types/modules?
- more complex to try to provide Curve#D.asBezier though...unless perhaps user has to pass desired degree
  (e.g. 'Curve2d.asBezier 3' to attempt to convert to a cubic Bezier curve)

Switch SurfaceFunction zero finding to use new Bisection module
- will need to implement solution curve trimming/merging

Use CBOR for FFI calls from target languages
-> have single calling function:
   void*
   opensolid_invoke(
     char* function,
     int64_t arguments_size,
     void* arguments_data,
     int64_t* result_size
   )
-> arguments are formatted as array
-> result_size can be set to be negative,
   in which case returned data is an error object in JSON-RPC format ('code', 'message')
-> much less room for segfaults, weird data corruption etc. - can't accidentally treat int as double or whatever
-> means that exact same format can be used in client-server way over WebSockets, HTTP, sockets, standard in/out streams etc.
-> can use Haskell 'serialise' library which seems nice and well supported

Add UvDebug module

Add Debug2D module

Add Debug3D module

Move SurfaceLinearization.error to SurfaceFunction3d.linearDeviation
-> Estimate with Gaussian integration instead of using e.g. second derivative bounds?
   Should be more accurate *and* more efficient...
   -> if curvature estimated by Gaussian integration changes by e.g. less than 1% when bisecting,
      then use that estimated curvature to 'jump' to the necessary subdivision size for linearization
-> probably OK if accuracy of mesh is not 100% guaranteed; it's an approximation anyways

Add batch evaluation functions?
- most important for target languages to avoid many FFI calls
  - curve.steps(n), curve.leading(n), curve.trailing(n) etc.?

Reduce use of HasField instances
-> 'actual Haskell fields' only? (including nested?)
-> Switch types over to being records
  -> curves and surface functions ('compiled' and derivatives)
-> maybe even disable OverloadedRecordDot? still use records for nice construction/destructuring...

Move 't', 'u' and 'v' into Parameter module?
-> then can rename e.g. 'Curve' to 'UnitlessCurve1D' (= Curve1d Unitless), 'Curve1D' can be 'Curve1d Meters' etc.
-> Parameter.t is a UnitlessCurve1D, Parameter.u is a UnitlessSurfaceFunction1D

Make Transform2D Meters-only?
-> *shouldn't* need to e.g. mirror UV points very often...
-> maybe also Axis2d, Frame2d
-> probably most consistent to just have all 2D types have units, though...
-> Transform2D/UvTransform, Axis2D/UvAxis, Frame2D/UvFrame!

Add modules for UvRegion, UvCurve etc.

Search for 'Unitless UvSpace' and 'Meters space' to see where type aliases can be used
-> or new ones introduced...

Add more Curve2d intersection tests
-> use cycloid as example of curve with singularity?
  -> make sure to test *end* singularity as well

Try to avoid use of squared tolerance in general, if possible
-> e.g. specialized implementation of Intersects for Curve2d and VectorCurve2d

Switch back to 'normal' (non-recursive) form of quotient derivatives
-> e.g. VectorSurfaceFunction3d
-> search for 'recursive' calls in general?

Rename 'interpolationParameter' to 'unterpolate'?

Flip argument order in Composition typeclass
-> rename to Composition2 temporarily to ensure all instances are updated

Rework Curve2d.medialAxis to use tangent directions instead of derivative vectors

Remove 'unconvert' functions

Clean up division by 'Curve units' or 'SurfaceFunction units' that is (approximately) identically zero by replacing with division by actual constant zero
-> or just *multiplication* by infinity...
-> Faster to evaluate, gives actual infinities instead of just extremely large values (more correct!)
-> Maybe also for division by e.g. 'Qty units', so division by *approximately* zero gives actual infinity?

Add Component3d class to Python library?
-> 'front_plane', 'upward_direction', 'rightward_axis' etc. convenience accessors in addition to 'frame'

Add vectorTransformations3d helper list in API module

Switch to upper-case 2D and 3D suffixes instead of 2d and 3d?
-> Point2D vs Point2d
-> Curve3D vs Curve3d
-> Body3D vs Body3d

Add indentation to debug output of Ast values for easier inspection

Optimization: check when e.g. VectorCurve#D or VectorSurface#D (squared) magnitude is a constant (within current tolerance)
-> avoid expensive square root (or even squared magnitude calculation!)

Add dedicated 'blend' expression
-> will still explode out to large derivative...
-> maybe even dedicated first derivative expression?
-> could then share computation of t^2, t^3, t^4 between coefficients...

Optimize dot and cross products of constants with Bezier curves in Ast module

Optimize VectorBounds3d.hullN

Optimize general face indices operations...

Replace 'Point2D (Qty# x#) (Qty# y#)' with 'Point2D# x# y#' once Point2D is migrated to use Double# values internally
-> or just create Point2D# as a *pattern* first, then eventually it will be the actual constructor...

To optimize:
- Have Vector#D use unboxed fields
- 'Flatten' VectorBounds#D?
- Point3d - Point3d

Ensure target language bindings gracefully handle exceptions such as higher-order zeros

Try adding -fexcess-precision as an optimization
-> in general, try: https://wiki.haskell.org/Performance/GHC#Crank_up_the_gcc_flags

Add way to represent arc length parameterization in bytecode?
-> pack tree structure into opcodes, then Bezier curve control points into constants?
-> or if curves move into C++, then have C++ function that takes list of segments (with endpoint values/derivatives) and constructs a piecewise curve directly in C++...

Combine computeValue and computeBounds into single templated function?
-> call out to generic or overloaded helper functions as needed

Try pdoc for Python documentation generation?
-> or possibly Material for MkDocs + mkdocstrings

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)
