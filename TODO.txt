Add simplified/optimized versions of blending function derivatives

Add dedicated bytecode instructions for blending functions (and their derivatives)
-> they'll get evaluated every time a desingularized function is evaluated, regardless of whether or not the result is used...

Merge e.g. 'Subdomain' and 'Domain1d'?
- just base on Float values instead of Int
- store recursion type (even though that could be inferred from endpoints...)

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Try using RequiredTypeArguments extension to avoid need for Proxy in FFI-related code?
-> a bit tricky since the 'representation' function probably still needs to take a Proxy argument...

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Review all 'sqrt', 'magnitude', 'direction' and 'tangentDirection' functions to ensure correct degeneracy removal
-> get rid of 'unsafeMagnitude' functions and 'NonZeroMagnitude' types

Use FFI struct syntax for calling into C++ as well as for target languages calling into Haskell?
-> avoid custom pokeElemOff etc. stuff when calling into C++
-> a bit less efficient in some cases though since e.g. allocating space for a list of values uses callocBytes (maybe should be mallocBytes?) instead of allocaBytes
  -> maybe have a way to indicate to FFI.store whether to use mallocBytes or allocaBytes?

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Update API.Class.buildClass to use field accessor syntax

Refactor Solve2d searching to use 'cross product' of Solve1d?

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)

Support optional named arguments in target languages
- maybe via wrapper functions where one argument is something like an 'Options a' value,
  wrapping a list of options/attributes in Haskell

Switch Body3d.cylinderAlong to accept separate start and end values instead of a Bounds
-> maybe Body3d.extruded, too? easier now that named arguments are supported...

Refactor tolerance handling in Python?
- set tolerances for different units separately/independently
- convenience functions like 'Tolerance.meters(1e-9)', 'Tolerance.degrees(1e-3)', 'Tolerance.unitless(1e-12)' etc.?
- also generic ones like 'Tolerance.length(Length.micrometers(10))' etc.
- have default tolerances pre-configured? 1e-9 meters, radians, and unitless...
  -> middle ground: 'Tolerance.defaults()' to set up default tolerances for everything
