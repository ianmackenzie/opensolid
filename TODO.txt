Go back to custom *, /, +, - operators, with e.g. .* used for expressions like "2 .* vector"?
-> could make ".*." an alias for the built-in "*" operator...

Replace use of e.g. curve.derivative with e.g. "let curve' = Curve2d.derivative curve"

Reduce use of HasField instances
-> 'actual Haskell fields' only? (including nested?)
-> Switch types over to being records
  -> curves and surface functions ('compiled' and derivatives)
-> maybe even disable OverloadedRecordDot? still use records for nice construction/destructuring...

Have e.g. Point2D and UvPoint be newtypes over internal units-generic Point2d type?
-> Region2D/UvRegion, Curve2D/UvCurve, Direction2D/UvDirection, Axis2D/UvAxis, Frame2D/UvFrame
-> Vector2D is still units-generic (can be used to implement Point2d!)
-> some boilerplate with forwarding functions etc., but:
  -> provides a nice place to put separate doc comments for e.g. UvPoint and Point2D
  -> allows API to be slightly different between types, e.g. UvAxis.u vs. Axis2D.x
-> OpenSolid.Point2D, OpenSolid.UvPoint, and OpenSolid.Polymorphic.Point2d

Standardize on 'global' and 'local' as plane/frame type parameters everywhere and remove 'Defines'

Make Transform2D Meters-only?
-> *shouldn't* need to e.g. mirror UV points very often...
-> maybe also Axis2d, Frame2d
-> probably most consistent to just have all 2D types have units, though...
-> Transform2D/UvTransform, Axis2D/UvAxis, Frame2D/UvFrame!

Switch order of 'space' and 'units' type parameters...
-> hopefully can mostly do it with a big regex
-> manually replace instances involving complex symbolic units products/quotients
  -> include basic units products/quotients in regex

New Uv module?
-> Uv.Space
-> Uv.Point, Uv.Direction, Uv.Curve etc. type aliases
-> Uv.Parameter with U and V values?

Refactor CoordinateSystem module now that it no longer has a CoordinateSystem type
-> OpenSolid.Uv module with 'Space' type?
-> then rename CoordinateSystem to LocalCoordinates?
-> or just have convention that Frame3d is 'Frame3d units global local' etc...or 'Frame3d units space defines'

Add modules for UvRegion, UvCurve etc.

Switch to Meters-default naming convention, e.g.:
- data Point2D_ units space
- type Point2D space = Point2D_ Meters space
- type UvPoint = Point2D_ Unitless UvSpace
- what about Vector2D, Vector3D?
  -> data Vector2D_ units space
  -> type Vector2D space = Vector2D_ Meters space
  -> type UnitlessVector2D space = Vector2D_ Unitless space
  -> type UvVector = UnitlessVector2D UvSpace
  -> type AreaVector2D space = Vector2D_ Area space
- should generic operations be in Point2D module or Point2D_ module?
- maybe keep 'Point2d' etc. names in Haskell, 'Point2D' and 'UvPoint' in target languages?
  -> still have 'Point3D' in Haskell? messy...
  -> maybe just have 'Point2D' be units-generic in Haskell, specific to meters in target languages
    -> also Region2D, Vector2D etc.
    -> still have UvPoint, UvVector, UvDirection, UvAxis, UvCurve etc. type aliases in Haskell

Search for 'Unitless UvSpace' and 'Meters space' to see where type aliases can be used
-> or new ones introduced...

Add more Curve2d intersection tests
-> use cycloid as example of curve with singularity?
  -> make sure to test *end* singularity as well

Try to avoid use of squared tolerance in general, if possible
-> e.g. specialized implementation of Intersects for Curve2d and VectorCurve2d

Split opensolid-core into opensolid-core and opensolid-geometry?
-> opensolid-core is basically an "alternative standard library", nothing about units or geometry
-> which one has OpenSolid.Prelude though?

Switch back to 'normal' (non-recursive) form of quotient derivatives
-> e.g. VectorSurfaceFunction3d
-> search for 'recursive' calls in general?

Juse use Aeson directly for JSON encoding/decoding?


Flip argument order in Composition typeclass
-> rename to Composition2 temporarily to ensure all instances are updated

Rework Curve2d.medialAxis to use tangent directions instead of derivative vectors

Remove 'unconvert' functions

Clean up division by 'Curve units' or 'SurfaceFunction units' that is (approximately) identically zero by replacing with division by actual constant zero
-> or just *multiplication* by infinity...
-> Faster to evaluate, gives actual infinities instead of just extremely large values (more correct!)
-> Maybe also for division by e.g. 'Qty units', so division by *approximately* zero gives actual infinity?

Tolerance-less desingularization?
-> detect degenerate endpoints by heuristic like 'endpoint value is less than 1e-9 times max of values at 3-point Gaussian quadrature points
  -> or maybe use golden ratio to provide random sampling points...
  -> still need to detect if denominator is zero *everywhere* though, and for that we still need a tolerance...

Add Component3d class to Python library?
-> 'front_plane', 'upward_direction', 'rightward_axis' etc. convenience accessors in addition to 'frame'

Rationalize use of forEach

Add vectorTransformations3d helper list in API module

Switch to upper-case 2D and 3D suffixes instead of 2d and 3d?
-> Point2D vs Point2d
-> Curve3D vs Curve3d
-> Body3D vs Body3d

Remove CoordinateSystem type and just use separate 'space' and 'units' type parameters where needed
  -> could allow removal of HasUnits in favour of assuming types always have units as the last type parameter...
  -> type names:
        Position2D space units (internal Position2D constructor)
        UvPoint (public UvPoint pattern)
        Point2D space (public Point2D pattern)
        Point3D space

        Vector2D space units (plus public constructor)
        UvVector (plus public pattern)
        UnitlessVector2D space (plus public pattern)
        Displacement2D space (plus public pattern)
        AreaVector2D space (plus public pattern)

        Vector3D space units
        UnitlessVector3D space
        Displacement3D space
        AreaVector3D space
    -> can have internal Position2D constructor and public UvPoint and Point2D patterns with fixed units

Add indentation to debug output of Ast values for easier inspection

Optimization: check when e.g. VectorCurve#d or VectorSurface#d (squared) magnitude is a constant (within current tolerance)
-> avoid expensive square root (or even squared magnitude calculation!)

Add dedicated 'blend' expression
-> will still explode out to large derivative...
-> maybe even dedicated first derivative expression?
-> could then share computation of t^2, t^3, t^4 between coefficients...

Optimize dot and cross products of constants with Bezier curves in Ast module

Optimize VectorBounds3d.hullN

Optimize general face indices operations...

Replace 'Point2d (Qty# x#) (Qty# y#)' with 'Point2d# x# y#' once Point2d is migrated to use Double# values internally
-> or just create Point2d# as a *pattern* first, then eventually it will be the actual constructor...

To optimize:
- Have Vector#d use unboxed fields
- 'Flatten' VectorBounds#d?
- Point3d - Point3d

Ensure target language bindings gracefully handle exceptions such as higher-order zeros

Try adding -fexcess-precision as an optimization
-> in general, try: https://wiki.haskell.org/Performance/GHC#Crank_up_the_gcc_flags

Add way to represent arc length parameterization in bytecode?
-> pack tree structure into opcodes, then Bezier curve control points into constants?
-> or if curves move into C++, then have C++ function that takes list of segments (with endpoint values/derivatives) and constructs a piecewise curve directly in C++...

Combine computeValue and computeBounds into single templated function?
-> call out to generic or overloaded helper functions as needed

Merge e.g. 'Subdomain' and 'Domain1d'?
- just base on Float values instead of Int
- store recursion type (even though that could be inferred from endpoints...)

Try pdoc for Python documentation generation?
-> or possibly Material for MkDocs + mkdocstrings

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Try switching back to plain let-in instead of abusing 'do' notation?

Try using normal 'do' notation for monads? Possibly with Try.do

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Refactor Solve2d searching to use 'cross product' of Solve1d?

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)

Support optional named arguments in target languages
- maybe via wrapper functions where one argument is something like an 'Options a' value,
  wrapping a list of options/attributes in Haskell

Add support for exponentiation operator in Python
-> possibly special-case it to only accept the literals 2 and possibly 3 as arguments
