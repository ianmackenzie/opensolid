Switch to desingularization 'width' of 0.005 instead of 0.001
-> especially important for surfaces not to have to bisect *too* much

Add desingularization of SurfaceFunction and VectorSurfaceFunction#d quotients

Add desingularizaiton of SurfaceFunction.sqrt

Update VectorSurfaceFunction#d.magnitude to use plain square root

Update VectorSurfaceFunction#d.direction to use division by magnitude directly

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Rename ZeroEverywhere -> IsZero?
-> shorter and more consistent with e.g. IsPoint
-> keep DivisionByZero to indicate specifically that denominator is zero

Review uses of unsafeQuotient

Refactor Qty.steps etc. to take count argument first?
-> 'count' refers to the first argument, like 'translateBy' refers to its first argument...

Special case composition to check for constant inputs
-> fall back to composeCurve/composeSurfaceFunction only if inner curve is non-constant
-> also add check in curveOfCurve, curveOfSurfaceFunction, surfaceFunctionOfCurve, surfaceFunctionOfSurfaceFunction etc.
-> need asConstant or similar in Curve, SurfaceFunction etc.?
  -> delegate to a new CompiledFunction.asConstant function? (and therefore Expression.asConstant, Ast.asConstant...)
  -> maybe have fancy Constant pattern for all those types?

Overhaul handling of discontinuities
- require curves/functions to implement composition directly, then remove Composition from Expression and Ast types
- update curve and surface function types to have special cases for quotients and square roots
- switch back to (p'q - q'p / q^2) form for quotients, so L'Hopital can be applied
- support L'Hopital for e.g. quotients of squares (where we need to divide *second* derivatives)
- add support for square root discontinuity in bytecode, Ast, Expression, function types
- support square root discontinuities in bytecode
- update Curve.sqrt' and SurfaceFunction.sqrt' to use specialized square root derivative expression
- review all 'sqrt', 'magnitude', 'direction' and 'tangentDirection' functions to ensure correct degeneracy removal
  - get rid of 'unsafeMagnitude' functions and 'NonZeroMagnitude' types

Use FFI struct syntax for calling into C++ as well as for target languages calling into Haskell?
-> avoid custom pokeElemOff etc. stuff when calling into C++
-> a bit less efficient in some cases though since e.g. allocating space for a list of values uses callocBytes (maybe should be mallocBytes?) instead of allocaBytes
  -> maybe have a way to indicate to FFI.store whether to use mallocBytes or allocaBytes?

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Update API.Class.buildClass to use field accessor syntax

Refactor Solve2d searching to use 'cross product' of Solve1d?

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)

Support optional named arguments in target languages
- maybe via wrapper functions where one argument is something like an 'Options a' value,
  wrapping a list of options/attributes in Haskell

Switch Body3d.cylinderAlong to accept separate start and end values instead of a Bounds
-> maybe Body3d.extruded, too? easier now that named arguments are supported...

Refactor tolerance handling in Python?
- set tolerances for different units separately/independently
- convenience functions like 'Tolerance.meters(1e-9)', 'Tolerance.degrees(1e-3)', 'Tolerance.unitless(1e-12)' etc.?
- also generic ones like 'Tolerance.length(Length.micrometers(10))' etc.
- have default tolerances pre-configured? 1e-9 meters, radians, and unitless...
  -> middle ground: 'Tolerance.defaults()' to set up default tolerances for everything
