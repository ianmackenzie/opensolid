Make GitHub repo public
-> add minimal README

Add Python docstrings
-> add extra line mentioning tolerance if one is required

Rename Colour to Color

Try using Pandoc to convert from Haddock to reStructuredText?
-> or just write all doc comments in plain text...

Add Python package README

Generate Python API docs

Add __abs__ support

Build out publishing workflow
- Build manylinux wheel in CI
  -> start locally?
- Build Mac x86-64 and ARM wheels in CI
- Build Windows wheel in CI
- Collect wheels and publish combined package

Improve Python bindings
- Allow Python classes to be represented by things other than pointers (e.g. plain float values for quantity types)
- Add magic IPython display functions to Curve2d, Drawing2d.Entity etc.
  -> using to-SVG (and eventually to-glTF) Haskell functions under the hood? ('display' functions?)
- Actual error types instead of strings
- Add _list_decode helper?
- Rename MemberFunction and StaticFunction to have U/R/M prefix *before* argument count
- Add support for 'intersects' operator (^)
  -> Also (&) for *intersection*?
- Adjust logic so that __contains__ doesn't check for named arguments

Switch Solve2d.return back to taking a single value instead of a NonEmpty

Move Http module out into separate opensolid-http package
-> reduce dependencies of libopensolid-ffi.so

Operator overload test suite: for every valid type and units combination, test that e.g. zero vector * zero range = zero vector bounds
- ensure every valid overload actually exists, and is resolved correctly at runtime

Support spaces / coordinate systems in bindings

Try generating C# bindings?

Try generating C++ bindings?

Sandbox executable to start generating Region2d medial axis curves and points?
-> need to be able to solve for medial axis of curve and *point* first

Introduce curve function types and properly support piecewise curves

Switch types back to 'space @ units' instead of 'coordinateSystem' where possible?
-> if that makes coercion more expensive, specialize arithmetic operators instead

Implement 1D monotonic solving in Rust

Specialize xComponent etc. for Parametric cases

Move primitives to Primitives.hs

Use space1 ~ space2 instead of space ~ space_ everywhere

Refactor Estimate to return an error if convergence fails/stalls

Specialize Multiplication for primitive types, for performance
-> avoid units coercion and extra typeclass lookup

Optimizations to try:
- cache expressions on Rust side (per thread?)
- refactor JIT code to directly generate 'primop' style code directly callable from Haskell
- add CMM wrappers around C functions so they can be directly used as primops
