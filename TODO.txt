Add ability to batch-evaluate functions?
-> try to avoid overhead of calling into C++ many times

Switch to desingularization 'width' of (1 / 256) instead of 0.001
-> especially important for surfaces not to have to bisect *too* much
-> seems good to use power of 2 so that corresponding derivative scaling is lossless

Add desingularization of SurfaceFunction and VectorSurfaceFunction#d quotients

Add desingularizaiton of SurfaceFunction.sqrt

Update VectorSurfaceFunction#d.magnitude to use plain square root

Update VectorSurfaceFunction#d.direction to use division by magnitude directly

Replace 'synthetic' curves with plain quartic Hermite splines

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Rename ZeroEverywhere -> IsZero?
-> shorter and more consistent with e.g. IsPoint
-> keep DivisionByZero to indicate specifically that denominator is zero

Review uses of unsafeQuotient

Refactor Qty.steps etc. to take count argument first?
-> 'count' refers to the first argument, like 'translateBy' refers to its first argument...

Re-introduce Functions or similar module so that all typeclass instances can be defined there?

Review all 'sqrt', 'magnitude', 'direction' and 'tangentDirection' functions to ensure correct degeneracy removal
-> get rid of 'unsafeMagnitude' functions and 'NonZeroMagnitude' types

Use FFI struct syntax for calling into C++ as well as for target languages calling into Haskell?
-> avoid custom pokeElemOff etc. stuff when calling into C++
-> a bit less efficient in some cases though since e.g. allocating space for a list of values uses callocBytes (maybe should be mallocBytes?) instead of allocaBytes
  -> maybe have a way to indicate to FFI.store whether to use mallocBytes or allocaBytes?

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Update API.Class.buildClass to use field accessor syntax

Refactor Solve2d searching to use 'cross product' of Solve1d?

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)

Support optional named arguments in target languages
- maybe via wrapper functions where one argument is something like an 'Options a' value,
  wrapping a list of options/attributes in Haskell

Switch Body3d.cylinderAlong to accept separate start and end values instead of a Bounds
-> maybe Body3d.extruded, too? easier now that named arguments are supported...

Refactor tolerance handling in Python?
- set tolerances for different units separately/independently
- convenience functions like 'Tolerance.meters(1e-9)', 'Tolerance.degrees(1e-3)', 'Tolerance.unitless(1e-12)' etc.?
- also generic ones like 'Tolerance.length(Length.micrometers(10))' etc.
- have default tolerances pre-configured? 1e-9 meters, radians, and unitless...
  -> middle ground: 'Tolerance.defaults()' to set up default tolerances for everything
