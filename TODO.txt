Add Component3d class to Python library?
-> 'front_plane', 'upward_direction', 'rightward_axis' etc. convenience accessors in addition to 'frame'

Update to newer GitHub Actions images?
-> in particular macos-13 is deprecated
-> but seems maybe a bit better for backwards compatibility to build on older OS versions...

Add vectorTransformations3d helper list in API module

Only support Meters units for 3D positional values?
-> still support e.g. unitless or area-valued vectors
-> then 3D transformation functions don't need frameUnits, axisUnits etc. hack
-> some types e.g. Model3d already assume meters-only...

Add indentation to debug output of Ast values for easier inspection

Optimization: check when e.g. VectorCurve#d or VectorSurface#d (squared) magnitude is a constant (within current tolerance)
-> avoid expensive square root (or even squared magnitude calculation!)

Add dedicated 'blend' expression
-> will still explode out to large derivative...
-> maybe even dedicated first derivative expression?
-> could then share computation of t^2, t^3, t^4 between coefficients...

Optimize dot and cross products of constants with Bezier curves in Ast module

Optimize VectorBounds3d.hullN

Optimize general face indices operations...

Replace 'Point2d (Qty# x#) (Qty# y#)' with 'Point2d# x# y#' once Point2d is migrated to use Double# values internally
-> or just create Point2d# as a *pattern* first, then eventually it will be the actual constructor...

To optimize:
- Have Vector#d use unboxed fields
- 'Flatten' VectorBounds#d?
- Point3d - Point3d

Try adding -fexcess-precision as an optimization
-> in general, try: https://wiki.haskell.org/Performance/GHC#Crank_up_the_gcc_flags

Add way to represent arc length parameterization in bytecode?
-> pack tree structure into opcodes, then Bezier curve control points into constants?
-> or if curves move into C++, then have C++ function that takes list of segments (with endpoint values/derivatives) and constructs a piecewise curve directly in C++...

Combine computeValue and computeBounds into single templated function?
-> call out to generic or overloaded helper functions as needed

Merge e.g. 'Subdomain' and 'Domain1d'?
- just base on Float values instead of Int
- store recursion type (even though that could be inferred from endpoints...)

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Try switching back to plain let-in instead of abusing 'do' notation?

Try using normal 'do' notation for monads? Possibly with Try.do

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Refactor Solve2d searching to use 'cross product' of Solve1d?

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)

Support optional named arguments in target languages
- maybe via wrapper functions where one argument is something like an 'Options a' value,
  wrapping a list of options/attributes in Haskell
