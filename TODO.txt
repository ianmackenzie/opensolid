Allow Set#d to be empty?
- would have to remove Set#d.bounds but that's probably OK...

Refactor Polygon2d.edges to filter out (approximately) zero-length edges?
- useful for removing duplicate last edge if last vertex is equal to first vertex
- often have polygons in UV space though...maybe just use *exact* equality?

Refactor curve construction from line segments?
- maybe also rename Curve2d.arc to Curve2d.arcFrom, add Arc2D type?
  - then move:
    - Curve2d.polarArc to Arc2d.polar
    - Curve2d.sweptArc to Arc2d.swept
    - Curve2d.cornerArc to Arc2d.corner
      - or Curve2d.fillet, since it can produce a line
      - or just remove it, since we have Region2d.fillet which is more flexible/powerful
      - or change Curve2d.fillet to act on two arbitrary curves?
    - Curve2d.radiusArc to Arc2d.withRadius or Arc2d.svg
      - replace WhichArc type with named #small argument plus Sign argument?
        - WhichArc seems nice, perhaps renamed to Arc2d.Which...
    - keep Curve2d.arcFrom without equivalent in Arc2d,
      since that can actually result in a line instead
- could then add Curve2d.asLine, Curve2d.asArc, Curve2d.asCircle etc.
- could also have Curve2D.Line, Curve2D.Arc, Curve2D.LineFrom, Curve2D.ArcFrom patterns
  - should even be able to map those to Python patterns!
- do for Curve3D too...add Line3D etc.

Add Bezier#d etc. types/modules?
- more complex to try to provide Curve#d.asBezier though...unless perhaps user has to pass desired degree
  (e.g. 'Curve2d.asBezier 3' to attempt to convert to a cubic Bezier curve)

Switch SurfaceFunction zero finding to use new Bisection module
- will need to implement solution curve trimming/merging

Use CBOR for FFI calls from target languages
-> have single calling function:
   void*
   opensolid_invoke(
     char* function,
     int64_t arguments_size,
     void* arguments_data,
     int64_t* result_size
   )
-> arguments are formatted as array
-> result_size can be set to be negative,
   in which case returned data is an error object in JSON-RPC format ('code', 'message')
-> much less room for segfaults, weird data corruption etc. - can't accidentally treat int as double or whatever
-> means that exact same format can be used in client-server way over WebSockets, HTTP, sockets, standard in/out streams etc.
-> can use Haskell 'serialise' library which seems nice and well supported

Units-specific types/modules
- 'type Point2D space = Point2d Meters space'
- 'type UvPoint = Point2d Unitless UvSpace'
- 'type Vector2D space = Vector2d Meters space'
- 'type UvVector = Vector2d Unitless UvSpace'
- 'type UvDirection = Direction2D UvSpace' <- a bit special...
- 'type Curve2D space = Curve2d Meters space'
- 'type UvCurve = Curve2d Unitless UvSpace'
- 'type Region2D space = Region2d Meters space'
- 'type UvRegion = Region2d Unitless UvSpace'
- 'type LineSegment2D space = LineSegment2d Meters space
- 'type UvLineSegment = LineSegment2d Unitless UvSpace'
- 'type Set2D a space = Set2d a Meters space' <- allowed?
- 'type UvSet a = Set2d a Unitless UvSpace' <- allowed?
- rule: lower-case 'd' has a units type parameter, capital 'D' does not (meters units for anything that *has* units)
- goal: application code does not need to use any lower-case 'd' types
- eventually move polymorphic modules under Polymorphic namespace?
  - e.g. OpenSolid.Polymorphic.Point2d
- remove doc comments from polymorphic modules

Add UvDebug module

Add Debug2D module

Add Debug3D module

Move SurfaceLinearization.error to SurfaceFunction3d.linearDeviation
-> Estimate with Gaussian integration instead of using e.g. second derivative bounds?
   Should be more accurate *and* more efficient...
   -> if curvature estimated by Gaussian integration changes by e.g. less than 1% when bisecting,
      then use that estimated curvature to 'jump' to the necessary subdivision size for linearization
-> probably OK if accuracy of mesh is not 100% guaranteed; it's an approximation anyways

Replace use of e.g. curve.derivative with e.g. "let curve' = Curve2d.derivative curve"

Add batch evaluation functions?
- most important for target languages to avoid many FFI calls
  - curve.evaluate(t)
  - curve.evaluate_bounds(t_bounds)
  - curve.to_polyline(resolution)
  - curve.steps(n), curve.leading(n), curve.trailing(n) etc.?

Reduce use of HasField instances
-> 'actual Haskell fields' only? (including nested?)
-> Switch types over to being records
  -> curves and surface functions ('compiled' and derivatives)
-> maybe even disable OverloadedRecordDot? still use records for nice construction/destructuring...

Move 't', 'u' and 'v' into Parameter module?
-> then can rename e.g. 'Curve' to 'UnitlessCurve1D' (= Curve1d Unitless), 'Curve1D' can be 'Curve1d Meters' etc.
-> Parameter.t is a UnitlessCurve1D, Parameter.u is a UnitlessSurfaceFunction1D

Make Transform2D Meters-only?
-> *shouldn't* need to e.g. mirror UV points very often...
-> maybe also Axis2d, Frame2d
-> probably most consistent to just have all 2D types have units, though...
-> Transform2D/UvTransform, Axis2D/UvAxis, Frame2D/UvFrame!

Add modules for UvRegion, UvCurve etc.

Switch to Meters-default naming convention, e.g.:
- data Point2D_ units space
- type Point2D space = Point2D_ Meters space
- type UvPoint = Point2D_ Unitless UvSpace
- what about Vector2D, Vector3D?
  -> data Vector2D_ units space
  -> type Vector2D space = Vector2D_ Meters space
  -> type UnitlessVector2D space = Vector2D_ Unitless space
  -> type UvVector = UnitlessVector2D UvSpace
  -> type AreaVector2D space = Vector2D_ Area space
- should generic operations be in Point2D module or Point2D_ module?
- maybe keep 'Point2d' etc. names in Haskell, 'Point2D' and 'UvPoint' in target languages?
  -> still have 'Point3D' in Haskell? messy...
  -> maybe just have 'Point2D' be units-generic in Haskell, specific to meters in target languages
    -> also Region2D, Vector2D etc.
    -> still have UvPoint, UvVector, UvDirection, UvAxis, UvCurve etc. type aliases in Haskell

Search for 'Unitless UvSpace' and 'Meters space' to see where type aliases can be used
-> or new ones introduced...

Add more Curve2d intersection tests
-> use cycloid as example of curve with singularity?
  -> make sure to test *end* singularity as well

Try to avoid use of squared tolerance in general, if possible
-> e.g. specialized implementation of Intersects for Curve2d and VectorCurve2d

Switch back to 'normal' (non-recursive) form of quotient derivatives
-> e.g. VectorSurfaceFunction3d
-> search for 'recursive' calls in general?

Rename 'interpolationParameter' to 'unterpolate'?

Flip argument order in Composition typeclass
-> rename to Composition2 temporarily to ensure all instances are updated

Rework Curve2d.medialAxis to use tangent directions instead of derivative vectors

Remove 'unconvert' functions

Clean up division by 'Curve units' or 'SurfaceFunction units' that is (approximately) identically zero by replacing with division by actual constant zero
-> or just *multiplication* by infinity...
-> Faster to evaluate, gives actual infinities instead of just extremely large values (more correct!)
-> Maybe also for division by e.g. 'Qty units', so division by *approximately* zero gives actual infinity?

Add Component3d class to Python library?
-> 'front_plane', 'upward_direction', 'rightward_axis' etc. convenience accessors in addition to 'frame'

Add vectorTransformations3d helper list in API module

Switch to upper-case 2D and 3D suffixes instead of 2d and 3d?
-> Point2D vs Point2d
-> Curve3D vs Curve3d
-> Body3D vs Body3d

Add indentation to debug output of Ast values for easier inspection

Optimization: check when e.g. VectorCurve#d or VectorSurface#d (squared) magnitude is a constant (within current tolerance)
-> avoid expensive square root (or even squared magnitude calculation!)

Add dedicated 'blend' expression
-> will still explode out to large derivative...
-> maybe even dedicated first derivative expression?
-> could then share computation of t^2, t^3, t^4 between coefficients...

Optimize dot and cross products of constants with Bezier curves in Ast module

Optimize VectorBounds3d.hullN

Optimize general face indices operations...

Replace 'Point2d (Qty# x#) (Qty# y#)' with 'Point2d# x# y#' once Point2d is migrated to use Double# values internally
-> or just create Point2d# as a *pattern* first, then eventually it will be the actual constructor...

To optimize:
- Have Vector#d use unboxed fields
- 'Flatten' VectorBounds#d?
- Point3d - Point3d

Ensure target language bindings gracefully handle exceptions such as higher-order zeros

Try adding -fexcess-precision as an optimization
-> in general, try: https://wiki.haskell.org/Performance/GHC#Crank_up_the_gcc_flags

Add way to represent arc length parameterization in bytecode?
-> pack tree structure into opcodes, then Bezier curve control points into constants?
-> or if curves move into C++, then have C++ function that takes list of segments (with endpoint values/derivatives) and constructs a piecewise curve directly in C++...

Combine computeValue and computeBounds into single templated function?
-> call out to generic or overloaded helper functions as needed

Try pdoc for Python documentation generation?
-> or possibly Material for MkDocs + mkdocstrings

Add hasZero functions that do simple check to see if a zero exists (plain bisection until bounds less than tolerance)
-> then use to check validity of L'Hopital desingularization (see if derivative or denominator has *any* zero)

Turn C++ hull2, hull3 etc. functions into just overloads of a 'hull' function

Ensure all fields are also available as normal functions
-> and those functions are the *primary* implementation
-> probably means we can avoid HasField instances in all .hs-boot files, expose functions instead

Split bytecode.h/bytecode.cpp into a few more files
-> e.g. helper functions for Bezier/Hermite evaluation
-> allow calling non-bytecode-specific functions from Haskell without having to use 'bytecode.h'...

Add DirectionCurve2d.[rotateLeft,rotateRight] and use in Curve2d.offsetBy, Region2d.fillet
-> best to implement right down to bytecode level...

Normalize HasField instances:
- move to top of file just under type definition
- always match a corresponding accessor function (usually just forward to that function)
